//
// Created by T.N.Brunshweeck on 25/12/2023.
//

#include "ZoneRegion.h"
#include <core/time/ZoneOffset.h>
#include <core/time/ZoneRules.h>


namespace core {
    namespace time {
        ZoneRegion ZoneRegion::of(const String &ID, gbool checkAvailable) {
            try {
                checkName(ID);
            } catch (const Exception &ex) { ex.throws(__trace("core.time.ZoneRegion")); }
            if ((ID.length() == 3) && ZIDs.containsKey(ID.toUpperCase())) {
                String const &trueID = ZIDs.get(ID);
                const ZoneRules &zRules = ZoneID::tzInfos.get(trueID);
                return ZoneRegion(trueID, zRules);
            } else if (ZoneID::tzInfos.containsKey(ID)) {
                const ZoneRules &rules = ZoneID::tzInfos.get(ID); /* generated by cldr */
                return ZoneRegion(ID, rules);
            } else if (checkAvailable) {
                Error("TimeZone Region not found: " + ID).throws(__trace("core.time.ZoneRegion"));
            } else {
                return ZoneRegion(ID, ZoneRules(ZoneOffset::UTC));
            }
        }

        void ZoneRegion::checkName(const String &ID) {
            gint const n = ID.length();
            if (n < 2) {
                DateTimeException("Invalid ID for region-based ZoneId, invalid format: " + ID)
                        .throws(__trace("core.time.ZoneRegion"));
            }
            for (gint i = 0; i < n; i++) {
                gchar const c = ID.charAt(i);
                if (c >= 'a' && c <= 'z') continue;
                if (c >= 'A' && c <= 'Z') continue;
                if (c == '/' && i != 0) continue;
                if (c >= '0' && c <= '9' && i != 0) continue;
                if (c == '~' && i != 0) continue;
                if (c == '.' && i != 0) continue;
                if (c == '_' && i != 0) continue;
                if (c == '+' && i != 0) continue;
                if (c == '-' && i != 0) continue;
                DateTimeException("Invalid ID for region-based ZoneId, invalid format: " + ID)
                        .throws(__trace("core.time.ZoneRegion"));
            }
        }

        ZoneRegion::ZoneRegion(const String &ID, const ZoneRules &rules) : ID(ID), zRules(rules) {
        }

        ZoneRegion ZoneRegion::of(const String &ID) {
            try {
                return of(ID, true);
            } catch (const Exception &ex) { ex.throws(__trace("core.time.ZoneID")); }
        }

        String ZoneRegion::id() const {
            return ID;
        }

        ZoneRules ZoneRegion::rules() const {
            return zRules;
        }

        ZoneOffset ZoneRegion::offset(glong epochSecond) const {
            return rules().offset(epochSecond);
        }

        ZoneRegion::ZoneRegion(const ZoneRegion &region) : ID(region.ID), zRules(region.zRules) {}

        ZoneRegion::ZoneRegion(ZoneRegion &&region) CORE_NOTHROW:
                ID(native::Unsafe::moveInstance(region.ID)), zRules(native::Unsafe::moveInstance(region.zRules)) {}

        ZoneRegion &ZoneRegion::operator=(const ZoneRegion &region) {
            if (this != &region) {
                ID = region.ID;
                zRules = region.zRules;
            }
            return *this;
        }

        ZoneRegion &ZoneRegion::operator=(ZoneRegion &&region) CORE_NOTHROW {
            if (this != &region) {
                ID = native::Unsafe::moveInstance(region.ID);
                zRules = native::Unsafe::moveInstance(region.zRules);
            }
            return *this;
        }
    } // time
} // core
